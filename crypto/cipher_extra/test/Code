/* ---------------------------- XAES-256-GCM ----------------------------
Specification: https://github.com/C2SP/C2SP/blob/main/XAES-256-GCM.md 
-----------------------------------------------------------------------*/
#define XAES_256_GCM_CTX_OFFSET      (sizeof(EVP_AES_GCM_CTX) + EVP_AES_GCM_CTX_PADDING)
#define XAES_256_GCM_KEY_LENGTH      (AES_BLOCK_SIZE * 2)
#define XAES_256_GCM_KEY_COMMIT_SIZE (AES_BLOCK_SIZE * 2)
#define XAES_256_GCM_CMAC_INPUT_SIZE (AES_BLOCK_SIZE * 2)
#define XAES_256_GCM_MAX_NONCE_SIZE  (AES_GCM_NONCE_LENGTH * 2)
#define XAES_256_GCM_MIN_NONCE_SIZE  (20)
#define USE_OPTIMIZED_CMAC                  

struct xaes_256_gcm_ctx {
#ifdef USE_OPTIMIZED_CMAC
    AES_KEY xaes_key; 
    uint8_t k1[AES_BLOCK_SIZE]; 
#else 
    uint8_t xaes_key[XAES_256_GCM_KEY_LENGTH];
#endif 
};

/* 
Left-shift a 128-bit register: https://words.filippo.io/xaes-256-gcm/ (line 2)
If MSB₁(L) = 0: K1 = L << 1;
Else: K1 = (L << 1) ⊕ (0x00, ..., 0x00, 0x87)
*/
#define BINARY_FIELD_MUL_X_128(out, in)             \
do {                                                \
    unsigned i;                                     \
    for (i = 0; i < 15; i++) {                      \
        out[i] = (in[i] << 1) | (in[i+1] >> 7);     \
    }                                               \
    const uint8_t carry = in[0] >> 7;               \
    out[i] = (in[i] << 1) ^ ((0 - carry) & 0x87);   \
} while(0);

static int xaes_256_gcm_CMAC_derive_key(struct xaes_256_gcm_ctx *xaes_ctx, 
                                const uint8_t* nonce, uint8_t *derived_key) { 
    uint8_t M1[AES_BLOCK_SIZE] = {0};
    uint8_t M2[AES_BLOCK_SIZE] = {0};

    M1[1] = 0x01; 
    M1[2] = 0x58; 
    OPENSSL_memcpy(M1 + 4, nonce, 12);
    OPENSSL_memcpy(M2, M1, AES_BLOCK_SIZE);

    M2[1] = 0x02;
#ifdef USE_OPTIMIZED_CMAC
    for (size_t i = 0; i < AES_BLOCK_SIZE; i++) {
        M1[i] ^= xaes_ctx->k1[i];
        M2[i] ^= xaes_ctx->k1[i];
    }

    AES_encrypt(M1, derived_key, &xaes_ctx->xaes_key);
    AES_encrypt(M2, derived_key + AES_BLOCK_SIZE, &xaes_ctx->xaes_key);
#else 
    AES_CMAC(derived_key, xaes_ctx->xaes_key, AES_BLOCK_SIZE * 2, M1, AES_BLOCK_SIZE);
    AES_CMAC(derived_key + AES_BLOCK_SIZE, xaes_ctx->xaes_key, AES_BLOCK_SIZE * 2, M2, AES_BLOCK_SIZE);
#endif 
    return 1;
}

static int xaes_256_gcm_set_gcm_key(EVP_CIPHER_CTX *ctx, const uint8_t *nonce, int enc) {

    EVP_AES_GCM_CTX *gctx = aes_gcm_from_cipher_ctx(ctx);

    // Nonce size: 20 bytes <= |N| <= 24 bytes
    if(gctx->ivlen < XAES_256_GCM_MIN_NONCE_SIZE || 
    gctx->ivlen > XAES_256_GCM_MAX_NONCE_SIZE) {
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_NONCE_SIZE);
        return 0;
    }

    struct xaes_256_gcm_ctx *xaes_ctx =
        (struct xaes_256_gcm_ctx *)((uint8_t*)ctx->cipher_data + XAES_256_GCM_CTX_OFFSET);

    uint8_t derived_key[XAES_256_GCM_KEY_LENGTH];

    xaes_256_gcm_CMAC_derive_key(xaes_ctx, nonce, derived_key);

    int ivlen = gctx->ivlen;

    // AES-GCM uses 12-byte nonce
    gctx->ivlen = AES_GCM_NONCE_LENGTH;
    
    // For nonce size < 24 bytes
    // Reference: https://eprint.iacr.org/2025/758.pdf#page=24
    aes_gcm_init_key(ctx, derived_key, nonce + ivlen - AES_GCM_NONCE_LENGTH, enc);

    // Re-assign the original nonce size of XAES-256-GCM (20 <= |N| <= 24)
    gctx->ivlen = ivlen;

    return 1;
}

static int xaes_256_gcm_ctx_init(struct xaes_256_gcm_ctx *xaes_ctx, const uint8_t *key) {
#ifdef USE_OPTIMIZED_CMAC 
    static const uint8_t kZeroIn[AES_BLOCK_SIZE] = {0};
    uint8_t L[AES_BLOCK_SIZE];
    AES_set_encrypt_key(key, XAES_256_GCM_KEY_LENGTH << 3, &xaes_ctx->xaes_key);
    AES_encrypt(kZeroIn, L, &xaes_ctx->xaes_key);
    BINARY_FIELD_MUL_X_128(xaes_ctx->k1, L);
#else 
    OPENSSL_memcpy(xaes_ctx->xaes_key, key, XAES_256_GCM_KEY_LENGTH);
#endif 
    return 1;
}

// ------------------------------------------------------------------------------
// --------------- EVP_CIPHER XAES-256-GCM Without Key Commitment ---------------
// ------------------------------------------------------------------------------
static int xaes_256_gcm_init(EVP_CIPHER_CTX *ctx, const uint8_t *key,
                            const uint8_t *iv, int enc) { 
    // Key length: 32 bytes
    if (ctx->key_len != XAES_256_GCM_KEY_LENGTH) {
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_KEY_LENGTH);
        return 0;
    }

    struct xaes_256_gcm_ctx *xaes_ctx =
            (struct xaes_256_gcm_ctx*)((uint8_t*)ctx->cipher_data + XAES_256_GCM_CTX_OFFSET);

    // Initialize the main key 
    if(key != NULL && !xaes_256_gcm_ctx_init(xaes_ctx, key)) {
        return 0;
    }

    // Derive a subkey
    if(iv != NULL) {
        return xaes_256_gcm_set_gcm_key(ctx, iv, enc);
    }

    return 1;
}

DEFINE_METHOD_FUNCTION(EVP_CIPHER, EVP_xaes_256_gcm) {
    OPENSSL_memset(out, 0, sizeof(EVP_CIPHER));
    out->nid = NID_xaes_256_gcm;
    out->block_size = 1;
    out->key_len = XAES_256_GCM_KEY_LENGTH;
    out->iv_len = XAES_256_GCM_MAX_NONCE_SIZE;
    out->ctx_size = sizeof(EVP_AES_GCM_CTX) + EVP_AES_GCM_CTX_PADDING 
                + sizeof(struct xaes_256_gcm_ctx); 
    out->flags = EVP_CIPH_GCM_MODE | EVP_CIPH_CUSTOM_IV | EVP_CIPH_CUSTOM_COPY |
                EVP_CIPH_FLAG_CUSTOM_CIPHER | EVP_CIPH_ALWAYS_CALL_INIT |
                EVP_CIPH_CTRL_INIT | EVP_CIPH_FLAG_AEAD_CIPHER;
    out->init = xaes_256_gcm_init;
    out->cipher = aes_gcm_cipher;
    out->cleanup = aes_gcm_cleanup;
    out->ctrl = aes_gcm_ctrl;
}

// ------------------------------------------------------------------------------
// ---------------- EVP_AEAD XAES-256-GCM Without Key Commitment ----------------
// ------------------------------------------------------------------------------
static int aead_xaes_256_gcm_init(EVP_AEAD_CTX *ctx, const uint8_t *key,
                            size_t key_len, size_t requested_tag_len) {
    // Key length: 32 bytes
    if (key_len != XAES_256_GCM_KEY_LENGTH) {
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_BAD_KEY_LENGTH);
        return 0;
    }
    
    // Max tag length: 16 bytes
    if(requested_tag_len > EVP_AEAD_AES_GCM_TAG_LEN) {
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_UNSUPPORTED_TAG_SIZE);
        return 0;
    }

    struct xaes_256_gcm_ctx *xaes_ctx =
        (struct xaes_256_gcm_ctx*)&ctx->state;

    xaes_256_gcm_ctx_init(xaes_ctx, key);

    ctx->tag_len = requested_tag_len;

    return 1;
}

static int aead_xaes_256_gcm_set_gcm_key(struct xaes_256_gcm_ctx *xaes_ctx, 
    struct aead_aes_gcm_ctx *gcm_ctx, const uint8_t *nonce, const size_t nonce_len) {
    
    if(!nonce || nonce_len < 20 || nonce_len > 24) {
        OPENSSL_PUT_ERROR(CIPHER, CIPHER_R_INVALID_NONCE_SIZE);
        return 0;
    }

    uint8_t gcm_key[XAES_256_GCM_KEY_LENGTH];

    xaes_256_gcm_CMAC_derive_key(xaes_ctx, nonce, gcm_key);
    
    gcm_ctx->ctr = aes_ctr_set_key(&gcm_ctx->ks.ks, &gcm_ctx->gcm_key, NULL,
                                gcm_key, sizeof(gcm_key));
    
    return 1;
}

static int aead_xaes_256_gcm_seal_scatter(
    const EVP_AEAD_CTX *ctx, uint8_t *out,
    uint8_t *out_tag, size_t *out_tag_len,
    const size_t max_out_tag_len,
    const uint8_t *nonce, const size_t nonce_len,
    const uint8_t *in, const size_t in_len,
    const uint8_t *extra_in,
    const size_t extra_in_len, const uint8_t *ad,
    const size_t ad_len) {
    
    struct xaes_256_gcm_ctx *xaes_ctx = (struct xaes_256_gcm_ctx*)&ctx->state;
    struct aead_aes_gcm_ctx gcm_ctx;

    if(!aead_xaes_256_gcm_set_gcm_key(xaes_ctx, &gcm_ctx, nonce, nonce_len)) {
        return 0;
    }
    
    return aead_aes_gcm_seal_scatter_impl(
        &gcm_ctx, out, out_tag, out_tag_len, max_out_tag_len,
        nonce + AES_GCM_NONCE_LENGTH, AES_GCM_NONCE_LENGTH,
        in, in_len, extra_in, extra_in_len, ad, ad_len, ctx->tag_len);
}

static int aead_xaes_256_gcm_open_gather(const EVP_AEAD_CTX *ctx, uint8_t *out,
                                    const uint8_t *nonce, size_t nonce_len,
                                    const uint8_t *in, size_t in_len,
                                    const uint8_t *in_tag, size_t in_tag_len,
                                    const uint8_t *ad, size_t ad_len) {
    struct xaes_256_gcm_ctx *xaes_ctx =
        (struct xaes_256_gcm_ctx*)&ctx->state;
    struct aead_aes_gcm_ctx gcm_ctx;

    if(!aead_xaes_256_gcm_set_gcm_key(xaes_ctx, &gcm_ctx, nonce, nonce_len)) {
        return 0;
    }
    
    return aead_aes_gcm_open_gather_impl(
        &gcm_ctx, out, nonce + AES_GCM_NONCE_LENGTH, AES_GCM_NONCE_LENGTH,
        in, in_len, in_tag, in_tag_len,
        ad, ad_len, ctx->tag_len);
}

DEFINE_METHOD_FUNCTION(EVP_AEAD, EVP_aead_xaes_256_gcm) {
    OPENSSL_memset(out, 0, sizeof(EVP_AEAD));
    out->key_len = XAES_256_GCM_KEY_LENGTH;
    out->nonce_len = XAES_256_GCM_MAX_NONCE_SIZE;
    out->overhead = EVP_AEAD_AES_GCM_TAG_LEN;
    out->max_tag_len = EVP_AEAD_AES_GCM_TAG_LEN;
    out->aead_id = AEAD_XAES_256_GCM_ID;

    out->init = aead_xaes_256_gcm_init;
    out->cleanup = aead_aes_gcm_cleanup;
    out->seal_scatter = aead_xaes_256_gcm_seal_scatter;
    out->open_gather = aead_xaes_256_gcm_open_gather;
}
==========================================================================================
36:
crypto/cipher_extra/test/xaes_256_gcm_tests.txt
==========================================================================================
2953:
!SpeedEvpCipherGeneric(EVP_xaes_256_gcm(), "EVP-XAES-256-GCM", kTLSADLen, selected) ||

3062: 
!SpeedAEADSeal(EVP_aead_xaes_256_gcm(), "AEAD-XAES-256-GCM", kTLSADLen, selected) ||
!SpeedAEADOpen(EVP_aead_xaes_256_gcm(), "AEAD-XAES-256-GCM", kTLSADLen, selected) ||

==========================================================================================

TEST(CipherTest, XAES_256_GCM_EVP_AEAD) {
    // Test invalid nonce sizes and key length
    {
        std::vector<uint8_t> key(32), nonce(24), plaintext(1), ciphertext(20);
        const size_t tag_size = 16;
        bssl::ScopedEVP_AEAD_CTX ctx;
        // Invalid key length
        int key_len = 24; 
        ASSERT_FALSE(EVP_AEAD_CTX_init(ctx.get(), EVP_aead_xaes_256_gcm(), key.data(), key_len, tag_size, nullptr));
        // Use 256-bit key length
        key_len = 32;
        // Encryption
        ASSERT_TRUE(EVP_AEAD_CTX_init(ctx.get(), EVP_aead_xaes_256_gcm(), key.data(), key_len, tag_size, nullptr));

        int nonce_len = 24;
        size_t plaintext_len = 0, ciphertext_len = 0;
        // Invalid nonce and nonce size
        ASSERT_FALSE(EVP_AEAD_CTX_seal(ctx.get(), ciphertext.data(), &ciphertext_len,
                                plaintext_len +  EVP_AEAD_max_overhead(EVP_aead_xaes_256_gcm()), 
                                nullptr, nonce_len, plaintext.data(), plaintext_len, nullptr, 0)); 
        nonce_len = 19;
        ASSERT_FALSE(EVP_AEAD_CTX_seal(ctx.get(), ciphertext.data(), &ciphertext_len,
                                plaintext_len +  EVP_AEAD_max_overhead(EVP_aead_xaes_256_gcm()), 
                                nonce.data(), nonce_len, plaintext.data(), plaintext_len, nullptr, 0));
        nonce_len = 25;
        ASSERT_FALSE(EVP_AEAD_CTX_seal(ctx.get(), ciphertext.data(), &ciphertext_len,
                                plaintext_len +  EVP_AEAD_max_overhead(EVP_aead_xaes_256_gcm()), 
                                nonce.data(), nonce_len, plaintext.data(), plaintext_len, nullptr, 0));

        nonce_len = 24;
        // Invalid max output size
        ASSERT_FALSE(EVP_AEAD_CTX_seal(ctx.get(), ciphertext.data(), &ciphertext_len,
                                plaintext_len, nonce.data(), nonce_len, plaintext.data(), 
                                plaintext_len, nullptr, 0));

        // Decryption   
        bssl::ScopedEVP_AEAD_CTX dctx;
        ASSERT_TRUE(EVP_AEAD_CTX_init(dctx.get(), EVP_aead_xaes_256_gcm(), key.data(), key_len, tag_size, nullptr));
        // Invalid nonce and nonce size
        nonce_len = 24;
        ASSERT_FALSE(EVP_AEAD_CTX_open(dctx.get(), plaintext.data(), &plaintext_len, ciphertext.size() - tag_size,
                                nullptr, nonce_len, ciphertext.data(), ciphertext.size(), nullptr, 0));
        nonce_len = 19;
        ASSERT_FALSE(EVP_AEAD_CTX_open(dctx.get(), plaintext.data(), &plaintext_len, ciphertext.size() - tag_size,
                                nonce.data(), nonce_len, ciphertext.data(), ciphertext.size(), nullptr, 0));
        nonce_len = 25;
        ASSERT_FALSE(EVP_AEAD_CTX_open(dctx.get(), plaintext.data(), &plaintext_len, ciphertext.size() - tag_size,
                                nonce.data(), nonce_len, ciphertext.data(), ciphertext.size(), nullptr, 0));
    }

    // Source of multi-loop tests: 
    // https://github.com/C2SP/C2SP/blob/main/XAES-256-GCM/go/XAES-256-GCM_test.go 
    const auto test = [](int n, const char *output) {
        bssl::ScopedEVP_MD_CTX s;        
        ASSERT_TRUE(EVP_DigestInit(s.get(), EVP_shake128()));
        bssl::ScopedEVP_MD_CTX d;        
        ASSERT_TRUE(EVP_DigestInit(d.get(), EVP_shake128()));

        std::vector<uint8_t> key(32), nonce(24), plaintext_len(1), plaintext(256);
        std::vector<uint8_t> aad_len(1), aad(256), ciphertext(272), decrypted(256);
        int key_len = 32, nonce_len = 24, tag_size = 16;

        for(int i = 0; i < n; ++i) {    
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), key.data(), key_len));
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), nonce.data(), nonce_len));
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), plaintext_len.data(), 1));
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), plaintext.data(), plaintext_len[0]));
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), aad_len.data(), 1));
            ASSERT_TRUE(EVP_DigestSqueeze(s.get(), aad.data(), aad_len[0]));

            // XAES-256-GCM Encryption
            bssl::ScopedEVP_AEAD_CTX ctx;
            ASSERT_TRUE(EVP_AEAD_CTX_init(ctx.get(), EVP_aead_xaes_256_gcm(), key.data(), key_len, tag_size, nullptr));

            size_t ciphertext_len = 0;
            ASSERT_TRUE(EVP_AEAD_CTX_seal(ctx.get(), ciphertext.data(), &ciphertext_len,
                                    plaintext_len[0] +  EVP_AEAD_max_overhead(EVP_aead_xaes_256_gcm()), 
                                    nonce.data(), nonce_len, plaintext.data(), plaintext_len[0], aad.data(), aad_len[0]));
            ASSERT_TRUE(EVP_DigestUpdate(d.get(), ciphertext.data(), ciphertext_len));

            // XAES-256-GCM Decryption
            bssl::ScopedEVP_AEAD_CTX dctx;
            ASSERT_TRUE(EVP_AEAD_CTX_init(dctx.get(), EVP_aead_xaes_256_gcm(), key.data(), 32, tag_size, nullptr));
            size_t len = 0;
            ASSERT_TRUE(EVP_AEAD_CTX_open(dctx.get(), decrypted.data(), &len, ciphertext_len - tag_size,
                                    nonce.data(), nonce_len, ciphertext.data(), ciphertext_len, aad.data(), aad_len[0]));
            ASSERT_EQ(Bytes(decrypted.data(), len), Bytes(plaintext.data(), plaintext_len[0]));
        }
        std::vector<uint8_t> expected;
        ConvertToBytes(&expected, output);
        uint8_t got[32] = {0};
        ASSERT_TRUE(EVP_DigestFinalXOF(d.get(), got, 32));
        ASSERT_EQ(Bytes(got, 32), Bytes(expected)); 
    };

    test(10000, "e6b9edf2df6cec60c8cbd864e2211b597fb69a529160cd040d56c0c210081939");
    test(1000000, "2163ae1445985a30b60585ee67daa55674df06901b890593e824b8a7c885ab15");
}
